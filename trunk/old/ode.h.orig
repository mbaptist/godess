//////////
//
//ODE.H
//Manuel Baptista, 26/06/2003
//
//Description:
// 
//Solves the 1st order ode d_t x(t) = f(x(t),t) by several methods
//
//Usage:
//
//1) Create a problem class (P). This class must have the following acessors:
//    double& get_dt()
//    double& get_tn()
//    T& get_ynp1()
//    T& get_yn()
//    T& get_ynm1()  //For Adams-Bashford only
//and an init() method to provide access to the initial condition.
//2) Declare a object of class odesolver<P,T,M>, where P is the problem class,
//T the type of ODE and M the method used. 
//3) Instatiate the problem, let's say problem_obj
//4) Instantiate the odesolver object, let's say odesolver_obj
//5) Use odesolver_obj.iterate(n_beg,n_end) as you please. 
//
//////////

#ifndef ODE_H
#define ODE_H

#include<iostream>

#include<string>

using std::string;

//ODESOLVER_DATA
//DECLARATION (IMPLEMENTATION INLINE)
//This class is inherited by the methods' classes below.
//The latter classes provide the problem to the constructor.
template <class P,class T> class odesolver_data
{
 public:
  //constructor
  odesolver_data(P& problem_):
    problem(problem_),    
    dt(problem.get_dt()),
    tn(problem.get_tn()),
    ynp1(problem.get_ynp1()),
    yn(problem.get_yn()){};
  //destructor
  ~odesolver_data(){};
 protected:
  //Problem
  P& problem;
  //Data References
  double& dt;//time dt
  double& tn;//current time
  T& ynp1;//next value
  T& yn;//current value
};

//ODESOLVER METHODS (M classes)
//DECLARATION
//These classes are inherited by the class ode_method, one at a time,
//as specified in the second template argument of ode_method.
//The last class provide the problem to the constructors.
//explicit euler method
template <class P,class T> class explicit_euler: public odesolver_data<P,T>
{
 public:
  explicit_euler(P& problem_):
    odesolver_data<P,T>(problem_){};
  ~explicit_euler(){};
  void method_iterate();
};
//Second order Runge-Kutta method
template <class P,class T> class runge_kutta_2: public odesolver_data<P,T>
{
 public:
  runge_kutta_2(P& problem_):
    odesolver_data<P,T>(problem_),
    aux1(yn.copy()),
    aux2(yn.copy()){};
  ~runge_kutta_2(){};
  void method_iterate(); 
 protected:
  double taux;
  T aux1;
  T aux2;
};
//Fourth order Runge-Kutta method
template <class P,class T> class runge_kutta_4: public odesolver_data<P,T>
{
 public:
  runge_kutta_4(P& problem_):
    odesolver_data<P,T>(problem_),
    aux1(yn.copy()),
    aux2(yn.copy()),
    aux3(yn.copy()),
    aux4(yn.copy()){};
  ~runge_kutta_4(){};
  void method_iterate(); 
 protected:
  double taux;
  T aux1;
  T aux2;
  T aux3;
  T aux4;
};
//Adams Bashford method
template <class P,class T> class adams_bashford: public odesolver_data<P,T>
{
 public:
  adams_bashford(P& problem_):
    odesolver_data<P,T>(problem_),
    ynm1(problem.get_ynm1()),
    aux(yn.copy()){};
  ~adams_bashford(){};
  void method_iterate();
  T& ynm1;
 protected:
  T aux;
};

//ODE_METHOD METHODS
//IMPLEMENTATION
//explicit euler method
template <class P,class T> void explicit_euler<P,T>::method_iterate()
{
  ynp1=yn+dt*problem.rhs(yn,tn);
}
//Second order Runge-Kutta method
template <class P,class T> void runge_kutta_2<P,T>::method_iterate()
{
  taux=tn+dt;
  //  aux1=dt*problem.rhs(yn,tn);
  aux1=problem.rhs(yn,tn);
  aux1 *= dt;
  aux2=yn;
  aux2 += aux1;
  taux=tn+dt;
  aux2=problem.rhs(aux2,taux);
  aux2 *= dt;
  ynp1=aux1;
  ynp1 += aux2;
  ynp1 *=.5;
  ynp1 += yn;
}
//Fourth order Runge-Kutta method
template <class P,class T> void runge_kutta_4<P,T>::method_iterate()
{
  aux1=dt*problem.rhs(yn,tn);
  taux=tn+dt/2.;
  aux2=yn+aux1/2.;
  aux2=dt*problem.rhs(aux2,taux);
  aux3=yn+aux2/2.;
  aux3=dt*problem.rhs(aux3,taux);
  taux=tn+dt/2.;
  aux4=yn+aux3;
  aux4=dt*problem.rhs(aux4,taux);
  ynp1=yn+(k1+2*k2+2*k3+k4)/6.;
}
//Adams Bashford method
template <class P,class T> void adams_bashford<P,T>::method_iterate()
{
  aux=yn;
  ynp1=problem.rhs(yn,tn);
  ynp1 *= 2;
  ynp1 *= dt;
  ynp1 += ynm1;
  ynm1=aux;
}

//ODESOLVER
//DECLARATION(IMPLEMENTATION INLINE) 
template <class P,class T,class M> class odesolver: public M
{
 public:
  //constructors
  odesolver(P& problem_):M(problem_){};
  //destructor
  ~odesolver(){};
  //Iterate
  void iterate(){
      tn += dt;
      method_iterate();
  };
  void iterate(int n){
    for (int i=0;i<n;i++){
      tn += dt;
      method_iterate();
    }
  };
  void iterate(int n_beg,int n_end){
    for (int i=n_beg;i<n_end;i++){
      tn += dt;
      method_iterate();
    }
  };
};

#if 0
//ODESOLVER
//DECLARATION(IMPLEMENTATION INLINE) 
template <class P,class T,class M> class odesolver
{
 public:
  //constructors
  odesolver(P& problem_):method(problem_){};
  //destructor
  ~odesolver(){};
  //Iterate
  
  void iterate(int n_beg,int n_end){
    for (int i=n_beg;i<=n_end;i++){
      method.tn=i*method.dt;
      method.iterate();
    }
  };
 private:
  //Method used
  M method;
};
#endif


#endif
